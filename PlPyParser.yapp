%{  my %symtab;
    my %printab;
    my %imports;
    my @print_vars;
    my @py_header;
    my @py_code; %}
%token NUMBER
%token SHEBANG
%token PRINT
%token END_OF_FILE
%token COMMENT
%token EMPTY_LINE
%token WHITESPACE
%token SEPARATOR
%token IF
%token NO_LINE
%token GTE
%token LTE
%token CHOMP
%token JOIN
%token EXIT
%token CREMENT
%left '-' '+'
%left '*' '/' '%'
%left '<' '>'
%left RANGE

%%

program     : line '\n'
            | program line '\n'
            ;

line        : statement
                {
                    my $s = $_[1];
                    # TODO: gross hacky
                    $s =~ s{[\$@]}{}g;
                    # if ($s =~ m{[^"'](.*)[^"']}) {
                    #     my $non_str = $1;
                    #     $non_str =~ s{%}{}g;
                    #     print "$non_str";
                    #     $s =~ s{$1}{$non_str}ge;
                    # }
                    # print "$s\n";
                    push @py_code, "$s\n";
                    do_imports($s);
                }
            | COMMENT { push @py_code, "$_[1]\n"; }
            | EMPTY_LINE { push @py_code, "\n"; }
            | END_OF_FILE
                {
                    print_py();
                    exit 0;
                }
            | SHEBANG { push @py_header, "#!/usr/local/bin/python3.5 -u\n"; }
            | UNKNOWN_TOK { push @py_code, "# $_[1]\n"; }
            | NO_LINE
            ;

statement   : print_st
            | assignment
            | condition
            | loop
            | chomp
            | string_func
            | read_op
            | regex
            | EXIT { return "sys.exit"; }
            | LAST { return "break"; }
            | NEXT { return "continue"; }
            | WHITESPACE statement { return join('', $_[1], $_[2]); }
            ;

regex       : var MATCH_OPERATOR MATCH
            | var MATCH_OPERATOR SUBS { return handle_re($_[1], $_[3]); }
            ;

string_func : JOIN '(' string SEPARATOR expr ')'
                {
                    return "$_[3].join($_[5])";
                }
            | SPLIT '(' MATCH SEPARATOR expr ')'
                {
                    return "$_[5].split('$_[3]')";
                }
            ;

print_st    : PRINT print_arg
                {
                    my $print_tok = $_[1];
                    my $args = $_[2];
                    return handle_print($print_tok, $args);
                }
            ;

print_arg   : expr
            | string_func
            | print_arg SEPARATOR string_func
            | print_arg SEPARATOR expr { "$_[1], $_[3]"; }
            ;

string      : SENTENCE
            | string SENTENCE
            ;

assignment  : var '=' expr
                {
                    return handle_assignment($_[1], $_[3]);
                }
            | var '=' input
                {
                    return handle_assignment($_[1], $_[3]);
                }
            | var CREMENT
                {
                    return handle_crement($_[1], $_[2]);
                }
            ;

input       : INPUT
                {
                    my $read_op = $_[1];
                    return handle_read_op($read_op);
                }
            ;

condition   : IF '(' truth ')' '{' { "$_[1] $_[3]:" }
            ;

expr        : expr '+' expr { "$_[1] + $_[3]" }
            | expr '-' expr { "$_[1] - $_[3]" }
            | expr '*' expr { "$_[1] * $_[3]" }
            | expr '/' expr { "$_[1] / $_[3]" }
            | expr '%' expr { "$_[1] % $_[3]" }
            |
            | expr RANGE expr
                {
                    my $start = $_[1];
                    my $end = $_[3];
                    return handle_range($start, $end);
                }
            | var
            | string
            | NUMBER
            ;

truth       : expr '>' expr { "$_[1] > $_[3]" }
            | expr '<' expr { "$_[1] < $_[3]" }
            | expr GTE expr { "$_[1] >= $_[3]" }
            | expr LTE expr { "$_[1] <= $_[3]" }
            | expr EQUAL expr { "$_[1] == $_[3]" }
            | expr NOT_EQUAL expr { "$_[1] != $_[3]" }
            | expr AND expr { "$_[1] and $_[3]" }
            | expr OR expr { "$_[1] or $_[3]" }
            | expr
            ;

loop        : LOOP_TYPE '(' truth ')' '{' { "$_[1] $_[3]:" }
            | LOOP_TYPE var '(' expr ')' '{'
                {
                    my $iterator = $_[2];
                    my $iterable = $_[4];
                    "for $iterator in $iterable:";
                }
            | LOOP_TYPE '(' assignment ')' '{' # var = read_op
                {
                    my $assn = $_[3];
                    return handle_input_loop($assn);
                }
            ;

chomp       : CHOMP #TODO
            | chomp var
                {
                    my $var = $_[2];
                    return handle_chomp($var);
                }
            ;

var         : VAR { return handle_var($_[1]); }
            | VAR INDEX
            ;
%%

use constant {
    _INT => "\%d",
    _FLOAT => "\%f",
    _STRING => "\%s",
};

my %syntax_lookup = (
    "<STDIN>" => "sys.stdin.readline()",
    "<>" => "fileinput.input()",

    "\@ARGV" => "sys.argv[1:]",
    "\$#ARGV" => "len(sys.argv) - 1", # $#ARGV is the last index, len is the
    # scalar
    # "ARGV" => "sys.argv",

    # "elsif" => "elif",

    # "eq" => "==",
    # "&&" => "and",
    # "||" => "or",
    # "!" => "not ",
);

sub print_py {
    my @modules;
    foreach my $module (keys %imports ){
        push @modules, $module;
    }
    if (scalar @modules > 0) {
        push (@py_header, (join('', "import ", join(', ', @modules)) . "\n"));
    }
    push my @py_program, (@py_header, @py_code);
    for (@py_program) {
        print "$_";
    }
}

sub handle_print {
    my $print_tok = $_[0];
    my $arg = $_[1];
    my $has_new_line = 0;

    # remove only trailing new lines
    # i.e. print "Hello\nWorld"; is passable
    if ($arg =~ m{\\n"\s*$}) {
        $has_new_line = 1;
        $arg =~ s{,\s*"\\n"\s*$}{}g; # remove , "\n"
        $arg =~ s{\\n\s*"\s*$}{"}g; # remove  \n in \n"
    }

    # vars that don't need type inference
    # print ($var) || print ""
    if ($arg =~ /^([^"]*)$/ || $arg =~ /^"?(\$[^\s\"]*)"?$/) {
        $arg = handle_var($1);
        $arg =~ s{\$}{}g;
    } else {
        my @components = split(/\s+/, $arg);
        my @vars;
        foreach my $component (@components) {
            if ($component =~ /\$\w+/) {
                my $replace = infer_var_type($component);
                $component =~ s{\$(\w+)}{$replace}g;
                push @vars, $1;
            }
        }
        $arg = join(' ', @components);
        if (@vars) {
            my @str_format = join(', ', @vars);
            if (scalar @vars > 1) {
                $arg .= " % (@str_format)";
            } else {
                $arg .= " % @str_format";
            }
        }
    }

    if ($has_new_line == 0) {
        $arg .= ", end=\"\"";
    }
    return "$print_tok($arg)";
}

sub infer_var_type {
    my ($var) = @_;
    return (exists $symtab{$var} && $symtab{$var} =~ m{^\d+$} ? _INT : _STRING);
}

sub handle_read_op {
    my $read_op = $_[0];
    if (exists $syntax_lookup{"<$read_op>"}) {
        return $syntax_lookup{"<$read_op>"};
    }
    return "$read_op";
}

sub handle_chomp {
    my $var = $_[0];
    return "$var = $var.rstrip()";
}

sub handle_var {
    my $var = $_[0];
    for my $pl_syntax (keys %syntax_lookup) {
        return $syntax_lookup{$pl_syntax} if $var =~ m{\Q$pl_syntax};
    }
    if ($var =~ m{\$ARGV\[(.*)\]}) {
        return "sys.argv[$1 + 1]"; #move over as in py, argv[0] is filename
    }
    return "$var";
}

sub handle_crement {
    my ($var, $crement) = @_;
    my $expr = "$var - 1";
    if ($crement eq "+") {
        $expr = "$var + 1";
    }
    return handle_assignment($var, $expr);
}

sub handle_assignment {
    my ($var, $expr) = @_;
    $symtab{$var} = $expr;
    return "$var = $expr";
}

sub handle_range {
    my ($start, $end) = @_;
    # evaluate end+1 if it's only a number, otherwise leave it as a string
    if ($start == 0 && $end =~ m{len\(sys\.argv\)\s*\-\s*1}) {
        $end = "len(sys.argv) - 1";
    } else {
        if ($end =~ m{(-+)?\s*\b(\d+)\b}) {
            my $operator = $1;
            my $num = $2;
            if ($operator && $operator eq "-") {
                $end =~ s{$num}{$num-1}e;
            } else {
                $end =~ s{$num}{$num+1}e;
            }
        } else {
            $end = "$end + 1";
        }
    }

    "range($start, $end)" ;
}

sub handle_input_loop {
    my ($assn) = @_;
    my @components = split(/\s+/, $assn);
    return "for $components[0] in $components[2]:";
}

sub handle_re {
    my ($var, $re) = @_;
    if ($re =~ m{s/(.*)/(.*)/}) {
        return "$var = re.sub(r'$1', '$2', $var)";
    }
    ### TODO: re match
    return "$var = re.match(r'$1', $var)";
}

sub do_imports {
    my $line = $_[0];
    if ($line =~ m{(sys|fileinput|re)\.}) {
        unless (exists $imports{$1} && $imports{$1} == 1) {
            $imports{$1} = 1;
        }
    }
}